/*
This program is written by GSC during 10/2012
It will creae a few in-memory tables to read reads-* files generated by D2

Internal structure of table is Excel-like.
Rows are tables reads / day (column value)

Maxima : 700 tables, at the moment 634
365 days of data
For each day, we stock Read / Update / Create

Header line is included
Extra line with totals / day is included

Output : comma-seperated list to be used in Excel 1 of R/U/C

Tablename / Date  01/01 02/01 03/01
TableA            valD1 valD2 valD3 READS
TableB            valD1 valD2 valD3 READS
TableC            valD1 valD2 valD3 READS
TableD            valD1 valD2 valD3 READS
Totals            totD1 totD2 totD3 READS

TableA            valD1 valD2 valD3 Update
TableB            valD1 valD2 valD3 Update
TableC            valD1 valD2 valD3 Update
TableD            valD1 valD2 valD3 Update

TableA            valD1 valD2 valD3 Create
TableB            valD1 valD2 valD3 Create
TableC            valD1 valD2 valD3 Create
TableD            valD1 valD2 valD3 Create
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dirent.h>

const int MAXTABLES=700;

int GunterFilter(const struct dirent *inp)
   {char *tmp=NULL;
    //printf(" Entering GunterFilter with %s\n",inp->d_name);
    tmp=strstr(inp->d_name,"reads");
    if (tmp)
       return 1;
    return 0;
   }

void TrimNum(char *s)
   {
    int i=0;
    int shift=0;
//    printf("Input is %s\n",s);
    while(s[i+shift])
       {
        if (s[i+shift] == '.')
           shift++;
        s[i]=s[i+shift];
        i++;
       }
    s[i]='\0';
//    printf("New number is %s\n",s);
    return;
   }

double ReadFile(char *name,double ***Totals,char **TName, int day)
   {
    double totalR=0, totalU=0, totalC=0;
    long int i=0;
    FILE *fp;
    char *buf=NULL;
    char *buf1=NULL;
    char *buf2=NULL;
    char *buf3=NULL;
    char *buf4=NULL;
    int tableindex=0;
    fp=fopen(name,"r");
    if ( !fp)
       {
        printf(" Error opening File !");
        exit(1);
       }
    buf=(char *) malloc(80*sizeof(char));
    if ( !buf)
       {
        printf(" Error allocating buffer !");
        exit(1);
       }
    buf1=(char *) malloc(80*sizeof(char));
    if ( !buf1)
       {
        printf(" Error allocating buffer !");
        exit(1);
       }
    buf2=(char *) malloc(80*sizeof(char));
    if ( !buf2)
       {
        printf(" Error allocating buffer !");
        exit(1);
       }
    buf3=(char *) malloc(80*sizeof(char));
    if ( !buf3)
       {
        printf(" Error allocating buffer !");
        exit(1);
       }
    buf4=(char *) malloc(80*sizeof(char));
    if ( !buf4)
       {
        printf(" Error allocating buffer !");
        exit(1);
       }
//    while (fread(buf,sizeof(char),56,fp))
    while (fgets(buf,80,fp))
       {
//        printf("Buffer read = %s",buf);
//        sscanf(buf,"%s;%s;%s",buf1,buf2,buf3);
        buf1=strtok(buf,";");
        strcpy(TName[tableindex],buf1);
        buf2=strtok(NULL,";"); // Read
        buf3=strtok(NULL,";"); // Update
        buf4=strtok(NULL,";"); // Create
        if (buf2)
           {
            TrimNum(buf2);
            i=strtol(buf2,NULL,10);
//            printf("Read %li from : %s / %s / %s \n",i,buf1,buf2,buf3);
            totalR+=i;
            Totals[tableindex][day][0]=i;
           }
        else
           Totals[tableindex][day][0]=0;
        if (buf3)
           {
            TrimNum(buf3);
            i=strtol(buf3,NULL,10);
            Totals[tableindex][day][1]=i;
            totalU+=i;
           }
        else
           Totals[tableindex][day][1]=0;
        if (buf4)
           {
            TrimNum(buf4);
            i=strtol(buf4,NULL,10);
            Totals[tableindex][day][2]=i;
            totalC+=i;
           }
        else
           Totals[tableindex][day][2]=0;
        tableindex++;
        if (tableindex >= MAXTABLES)
          {
           printf(" Too many tables read > %d\n",MAXTABLES);
           exit(1);
          }
       }
    strcpy(TName[tableindex],"Totals	:");
    TName[tableindex+1]=NULL;
    fclose(fp);
    //printf(" Total %s = %.0f\n",name,total);
    Totals[tableindex][day][0]=totalR; // Last line in table is day total 
    Totals[tableindex][day][1]=totalU; // Last line in table is day total 
    Totals[tableindex][day][2]=totalC; // Last line in table is day total 
//    printf("File %s Index : %d\n",name,tableindex);
// Injection of free for buf? generates core dump ???? How Come ?
    return 0;
   }

// type = O Read, 1 Update 2 Create
int PrintTable(double ***Table,char **Titles,char **TName,int maxday,int type)
   {int i=0,j=0;
    char *Type[3] = {"Read","Update","Create"};
    if ((type > 2))
       {
        printf(" Error in PrintTable : type out of range\n");
        exit(1);
       }
    printf(" Stats for %s\n",Type[type]);
    while (Titles[i])
       printf("%s,",Titles[i++]);
    printf("\b \n");
    i=0;
    while (TName[i]) // TableName exists ...
       {
        printf("%s",TName[i]);
        for (j=0;j<maxday;j++)
           {
            printf(",%.0f",Table[i][j][type]); // Print Reads
           }
        printf("\n"); // New table
        i++;
       }
    printf("%d pieces of data were processed\n",maxday);
   }

int main(int argc, char **argv)
   {
    struct dirent **namelist;
    int nfiles=scandir(".",&namelist,GunterFilter,alphasort);
    int divider=nfiles;
    int i=0,j=0,day=0; // Day is first index
    int type=0; // Argument to pass 
    double ***Gtotal; // Table with all totals / DBtable
    char **TableName, **Titles;
    if (argc > 1)
       {
        printf(" %d arguments specified\n",argc);
        type=atoi(argv[1]);
       }
    Titles=(char **) malloc (365 * sizeof(char *)); // Max 1 year
    if (!Titles)
       {
        printf(" Error allocating memory for Titles\n");
        exit(1);
       }
    for (i=0;i<365;i++)
       {
        Titles[i]=(char *) malloc (80 * sizeof(char));
        if (!Titles[i])
           {
            printf(" Error allocating memory for Titles\n");
            exit(1);
           }
       }
    strcpy(Titles[0],"TableName");
    TableName=(char **) malloc (MAXTABLES * sizeof(char *)); 
    if (!TableName)
       {
        printf(" Error allocating memory for tablenames\n");
        exit(1);
       }
    Gtotal=(double ***) malloc (MAXTABLES * sizeof(double **)); 
    if (!Gtotal)
       {
        printf(" Error allocating memory for table\n");
        exit(1);
       }
    for (i=0;i<MAXTABLES;i++) // For each table allocate 365 days worth of data
       {
        Gtotal[i] = (double **) malloc(365 * sizeof(double *));
        TableName[i] = (char *) malloc(80 * sizeof(char));
        if (!Gtotal[i])
           {
            printf(" Error allocating memory for table\n");
            exit(1);
           }
        else
           {
            for (j=0;j<365;j++) // Max 365 dagen
               {
                Gtotal[i][j] = (double *) malloc (3 * sizeof(double));
                if (! Gtotal[i][j])
                   {
                    printf(" Error allocating memory for table\n");
                    exit(1);
                   }
               }
           }
        if (!TableName[i])
           {
            printf(" Error allocating memory for tablename\n");
            exit(1);
           }
       }
    if (nfiles <= 0)
       {
        printf(" Error in directory listing \n");
        exit(1);
       }
    else
      {
       while (nfiles--)
          {
           // printf("%s\n",namelist[nfiles]->d_name);
           ReadFile(namelist[nfiles]->d_name,Gtotal,TableName,day++);
           strncpy(Titles[day],namelist[nfiles]->d_name+10,10);
           Titles[day][10] = '\0';
           free(namelist[nfiles]);
          }
       free(namelist);
      }
    Titles[day]=NULL;
    if (type==3)
       {
        PrintTable(Gtotal,Titles,TableName,day-1,0);
        PrintTable(Gtotal,Titles,TableName,day-1,1);
        PrintTable(Gtotal,Titles,TableName,day-1,2);
       }
    else
       PrintTable(Gtotal,Titles,TableName,day-1,type);
    for (i=0;i<MAXTABLES;i++)
       {
        for (j=0;j<365;j++)
           free(Gtotal[i][j]);
        free(Gtotal[i]);
        free(TableName[i]);
       }
    free(Gtotal);
    free(TableName);
    return 0;
   }
